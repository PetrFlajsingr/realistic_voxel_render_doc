Úvod
uvod
Nejpopulárnějším způsobem modelování a reprezentace dat pro vykreslování je v současné době využití trojúhelníkových sítí, ale existují i další přístupy. Jednou z poměrně populárních alternativ je využití voxelů. I přes to, že voxelové reprezentace jsou v real-time grafice v menšině, lze nalézt spoustu zdrojů a vědeckých článků o této problematice.

Vzhledem ke změnám možností využití grafické karty, především existenci compute shaderů, je práce s voxely mnohem jednodušší, než tomu bylo v dřívějších dobách. Není nutné provádět převod na trojúhelníky a můžeme pracovat s voxelovými primitivy přímo. Tím se odemyká možnost využití optimalizovaných algoritmů. Tato práce se zabývá zobrazováním voxelových scén za pomocí moderních metod a nástrojů, které jsou vývojářům poskytnuty.

První kapitola si dává za cíl seznámit čtenáře s řešenou problematikou. Vysvětluje základní principy realistického zobrazování a některé populární metody, jimiž je toho možné dosáhnout. Také popisuje, co jsou voxely, jak se s nimi dá pracovat v kontextu rozdělení prostoru a základní metody vykreslování. Dále jsou zde popsány vybrané hierarchické struktury, pomocí kterých lze urychlit průchod voxelovým prostorem. V poslední řadě obsahuje krátký popis moderního API pro práci s grafickými kartami: Vulkan.

Kapitola druhá se zabývá návrhem řešení. Je zde popsán způsob reprezentace voxelových dat s využitím akcelerační struktury a její detaily. Kapitola také vysvětluje navrhovaný způsob vykreslování voxelových scén s využitím ray casting přístupu.

Následující kapitola se zabývá specifikami implementace. V prvé radě jsou uvedeny nástroje a knihovny využité v samotné implementaci. Dále jsou popsány knihovny, které byly v rámci práce vytvořeny: knihovna obsahující obecné nástroje, knihovna pro usnadnění práce s Vulkan a GLFW, a knihovna pro vytváření a interkaci s uživatelským rozhraním. Také je zde popsán algoritmus načítání voxelových scén a jejich převod do tíženého formátu. Poslední sekce krátce popisuje uživatelské rozhraní demonstrační aplikace.

Poslední kapitola se věnuje vyhodnocením dosažených výsledků. V současné době obsahuje analýzu času převodu scén do octree. Popisuje také paměťovou náročnost transformovaných scén.

Teorie
teorie
Cílem této kapitoly je seznámit čtenáře s koncepty nutnými pro pochopení vlastního řešení. Kapitola vysvětluje, co je to voxel a jaká jsou jeho hlavní využití v počítačové grafice. Také popisuje fotorealistické zobrazování a vykreslování voxelových scén obecně. Jsou zde popsány často používané akcelerační struktury pro vykreslování voxelových modelů.

Realistické zobrazování
Tato sekce popisuje princip a použití různých technik realistického zobrazování používaného v současné počítačové grafice. Jsou zde uvedeny pouze relevantní informace související s tématem a předpokládá se znalost základních termínů.

Realistické zobrazování je podle knihygfx_principles_practice definováno jako tvoření obrazu podle definovaného modelu scény a osvětlení v ní přítomné. Jednotlivé pixely ve vytvořeném snímku (angl. rendered image) se dají chápat jako množství světla procházejícího podél paprsků ve scéně; to odpovídá integrálu vstupující světelné energie v bodě, případně v regionu.

Dle knihyreal_time_render, základní komponentou zobrazování v počítačové grafice je zobrazovací řetězec (angl. rendering pipeline). Funkcí zobrazovacího řetězce je vygenerování dvourozměrného snímku daného virtuální kamerou, scénou obsahující vykreslované modely a zdroji světla.

V článkurender_eq je představena zobrazovací rovnice. Je to integrální rovnice, jež zobecňuje přenos světelných paprsků ve scéně. Rovnice je ve tvaru

equation eq:render
	gathered
	I(x, x') = g(x, x') [(x, x') + _S(x, x', x")I(x', x")dx"]
	gathered
equation

kde  je intenzita světla z bodu  do bodu ,  je geometrický term reprezentující zastínění povrchu mezi body  a ,  značí intenzitu emitujícího světla z bodu  do bodu  a  představuje intenzitu rozptýleného světla z bodu  do bodu  přes plochu povrchu . Integrál je vypočten přes , tedy jako sjednocení všech povrchů, kdy  je dostatečně velká hemisféra uzavírající celou scénu.

Jak je dále uvedeno v článkurender_eq, rovnice vychází z fyzikální rovnice radiozity. Popisuje přenos intenzity světla z jednoho povrchového bodu do jiného jako sumu emitovaného osvětlení a celkové intenzity rozptýleného světla v bodě  od všech okolních povrchových bodů.

Podobná zobrazovací rovnice byla představena souběžně se dříve zmíněnou rovnicí v článkurender_eq_2. Tato rovnice je popsána pomocí vektorů a je v literatuře používána častěji. Nejznámější formu zobrazovací rovnice popisuje knihagfx_principles_practice:

equation eq:render_2
	gathered
	L_out(P, _0) = L_e(P, ) + __iS^2(p)L_in(P, -_i)f_s(P, _i, _0)(_i n_P)d_i
	gathered
equation
kde  je příchozí () či odchozí () světlo v bodě  ve směru ,  je normála povrchu v bodě ,  značí příchozí směr světla,  analogicky odchozí směr světla a  je sjednocení všech povrchů.  je světlo vyzářené pryč z bodu  ve směru  (tedy směrem k pozorovateli),  je emitované světlo,  je světlo přicházející z  a  je obousměrná distribuční funkce odrazu světla (BRDF) (světlo odražené z  k ).

Existuje mnoho metod realistického zobrazování, následuje základní popis vybraných.

Ray tracingsec:ray_tracing
Neboli sledování paprsku. Pravděpodobně nejznámější metoda globálního osvětlení. Knihaadvanced_global popisuje ray tracing jako algoritmus počítající radianční hodnotu  pro každý pixel ve výsledném obrázku. Tato hodnota je váženou hodnotou osvětlení ve scéně obsaženou v cestě paprsku:

equation eq:rt_1
	gathered
	L_pixel = _imageplaneL(p  eye)h(p)dp 
= _imageplaneL(x  eye)h(p)dp
	gathered
equation
kde  je bod na rovině obrázku a  váhová či filtrační funkce,  je viditelný bod od kamery skrze .

figure[H]
		obrazky-figures/ray_tracing_plane.png
	Interakce paprsku se scénou
	Zdroj:advanced_global
	fig:3d_grid
figure


Jak název napovídá, ray tracing používá paprsky k výpočtu barvy výsledného obrázku. Paprsek je polopřímka a je tedy definován počátečním bodem  (origin) a směrem  (direction). Nutnou funkcí pro funkčnost tohoto algoritmu je výpočet průsečíku paprsku s primitivy, pomocí kterých je scéna vytvořena. Možnosti výpočtu průsečíku paprsku s voxelem je popsána v sekci sec:voxel_intersection. Jednoduchý ray tracing je popsán v algoritmu alg:rt_1. Takto naivní implementace je samozřejmě velice neefektivní a pro běžně používané scény je nutné použít akcelerační struktury pro urychlení hledání průsečíkuaccelerated_rt. Pro realistické zobrazování jsou krom primárních paprsků generovány i paprsky sekundární. Tyto paprsky jsou použity například pro odrazy, refrakci a stíny.

Ve své standardní formě ray tracing neumožňuje generování měkkých stínů a spousty dalších sekundárních efektů.  Pro dosažení tíženého efektu lze využít například Monte carlo ray tracing (stochaistic ray tracing nebo distributed ray tracing)distributed_rt. Namísto jediného paprsku pro výpočet stínů, odrazů a refrakcí je využito paprsků více a výsledky jejich výpočtu jsou následně průměrovány. Metoda umožňuje vytvoření mnoha dalších efektů, jako například hloubka pole, rozmazání pohybu atd.

center
	czechalgorithm[H] alg:rt_1
	ray = buildray(camera.position, imageplane)

	mindistance = MAX

	hitprimitive = false

	primitive in scene 
	(intersected, distance) = intersect(ray, primitive)

	intersected distance < mindistance
	hitprimitive = primitive

	mindistance = distance

	
	
	Ray tracing
	czechalgorithm
center

Ray marching
Za zmínku stojí také algoritmus ray marching (sphere tracing). Namísto přímého výpočtu průsečíku se scénou - jak tomu je u spousty ray tracing implementací - postupuje paprsek ve scéně postupně, dokud nedojde k průsečíku.

figure[H]
		obrazky-figures/ray_marching.png
	Ray marching
	Zdroj:Keinert2014EnhancedST
	fig:ray_marching
figure

Článeksphere_tracing popisuje algoritmus následovně. Podmínkou funkčnosti algoritmu je mít možnost vypočítat z každého bodu ve scéně vzdálenost k jejímu povrchu. Pro tento účel lze využít takzvaných signed distance functions (SDF). Pro každý paprsek, kdy generování paprsků probíhá stejně jako u již zmíněného ray tracing, se iteruje napříč scénou dokud do ní paprsek nenarazí, nepřekoná maximální počet iterací či vykreslovací vzdálenost (algoritmus alg:ray_marching).


center
	czechalgorithm[H] alg:ray_marching
	i = 0

	t = tmin

	t < tmax i < MAXITERATIONS

	distancetoscene = distfunc(ray)

	distancetoscene < 

	t

	

	t += distancetoscene

	i += 1

	

	tmax

	Ray marching
	czechalgorithm
center

Pro tento algoritmus existuje značné množství optimalizacíKeinert2014EnhancedST. Jako je například "over-relaxation", kdy dochází k záměrně většímu kroku a případnému návratu zpět. Dalším příkladem je namísto sledování paprsku použít kužel, což značně snižuje množství iterací algoritmu.


Light field probes sec:light_field_probes
Metoda globální iluminace využívající ray tracing, byla představena v publikacilight_field_probes. Pracuje na předpokladu, že kontinuální světelné pole scény , kde  je bod v prostoru a  je odchozí směr, reprezentuje distribuci osvětlení ve scéně pro všechny body a směry ve scéně. Light field probes reprezentuje tuto distribuci pomocí diskrétního vyobrazení.

Prostor ve scéně je rozdělen pomocí pravidelné mřížky a do každé diskrétní pozice  je umístěna instance jedné sondy (probe), která mapuje směry  kolem  na: intenzitu osvětlení , normály  v bodech  nejblíže bodu  a hloubkovou mapu mezi  a body . K výpočtu těchto hodnot dochází při přípravě scény.

figure[H]
		obrazky-figures/light_field_probes.png
	Sondy umístěné ve scéně
	Zdroj:light_field_probes
	fig:ray_marching
figure

Algoritmus vykreslování postupuje napříč před-připravenými sondami. Při průchodu paprskem dochází k výběru sondy, trasování uvnitř ní a následně opakuje tento proces napříč scénou, dokud nedojde k jisté intersekci nebo minutí geometrie scény.

Radiozita
Metody radiozity byly vyvinuty již v padesátých letech minulého století pro simulaci tepelného přenosu. Později byla popsána varianta pro vykreslování v článkuradiosity. Metoda je založena na jednoduchém principu; vzhledem k tomu, že každý povrch ve scéně může odrážet světlo, se dá tento povrch považovat za zdroj světla. Radiozita povrchu je dána rovnicí:


equation eq:voxel_coords
	gathered
	B_i = E_i + _i ^N_j = 1B_jF_ij  pro  i = 1  do  N
	gathered
equation

Kde  je celkové množství energie vyzařované z povrchu,  je množství energie vyzařované v povrchu bez vlivu okolí,  je faktor reflexivity,  je faktor určující jaká část energie dorazila na povrch a  je počet povrchů ve scéně.

Z mého průzkumu vyplývá, že je radiozita primárně používána pro předvýpočet globální iluminace v některých scénách a dále není opakovaně počítána. Důvodem je nejspíše poměrně velká náročnost algoritmu.

Materiály
Pro simulaci interakce světla s povrchy je nutné mít tyto povrchy popsány určitými parametry. Použité parametry závisí na osvětlovacím modelu a také renderovacímu algoritmu. Publikacematerials popisuje interakci světla s povrchem rovnicí:

equation eq:surface_photon
	gathered
	(x, y, , , t, )_in  (x, y, , , t, )_out
	gathered
equation

kde levá strana reprezentuje foton interagující s povrchem a pravá strana foton vycházející ven,  je pozice na povrchu,  je příchozí/odchozí směr,  je čas interakce a  je vlnová délka. Pro zjednodušení lze z rovnice odstranit čas, čímž předpokládáme, že se vzhled povrchu s časem nemění. Při diskretizaci vlnových délek je možné dosáhnout dalšího zjednodušení, čímž dostaneme takzvanou BSSRDF (bidirectional scattering surface distribution function). Dalším zjednodušením může být ignorování podpovrchového rozptylu světla (subsurface scattering), čímž získáme již známé BRDF (bidirectional reflectance distribution function) (rovnice eq:brdf).

equation eq:brdf
	gathered
	f_r(c, _i  _0) = dL_0(x, _0)dE(x, _i 

	= dL_0(x, _0)L_i(x, _i)_i d_i
	gathered
equation

Kde  je podíl intenzity světla vycházející z povrchu na bodu  ve směru  a intenzity světla příchozího do bodu  ze směru .

Dle knihyhunter_harold_1987 můžeme materiály dělit do několika základních kategorií podle typu interakce se světlem:

table[H]
		tabularll
		materiál              & dominantní distribuce 
 	průhledný nemetalický & difuzní odraz         
 	metalický             & zrcadlový odraz       
 	průsvitný             & difuzní přenos        
 	průhledný             & běžný přenos          
 	tabular
	Typy materiálů a jejich interakce se světlem
table

figure[H]
		obrazky-figures/reflection_types.png
	Typy odrazu světla (difuzní, zrcadlové, lesklé)
	Zdroj:materials
	fig:3d_grid
figure

Dalším podstatným parametrem je tvar povrchu. Tvar povrchu výrazně mění to, jak dochází k odrazu světla. Vzhledem k potenciální složitosti této vlastnosti se používají například následující metody:

itemize
	Mapování normál (normal mapping)
	Parallax mapping
itemize

Příklady některých možných vlastností materiálů:

itemize
	barva
	hrubost
	metalické
	mapa normál
	emisivita
	průhlednost
	odrazivost
	spousta dalších...
itemize


Antialiasing
Aliasing je nechtěný efekt při zpracování signálu, kdy dochází ke vzniku artefaktů při vzorkování. Při vykreslování se jedná především o problém při vzorkování textur a artefakty na hranách objektu či přechodu mezi nimi (obrázek fig:aliasing). Existuje spousta metod pro odstranění tohoto efektu. Podleaa_survey můžeme metody pro antialiasing dělit do následujících kategorií:

itemize
	Full-Scene Anti-Aliasing (FSAA)
	Image Post-Processing Anti-Aliasing (IAA)
	Geometric Anti-Aliasing (GAA)
itemize

Každá z těchto kategorií má trochu jiný přístup k problému aliasingu s různými limitacemi.

figure[H]
		obrazky-figures/aliasing.png
	Aliasing
	fig:aliasing
figure

Příkladem FSAA je Super Sampling Anti-Aliasing (SSAA), kde je počet pixelů pro renderování navýšen oproti cílové velikosti renderovaného obrázku. Při dokončení jsou přilehlé pixely a jejich barva/hloubka zprůměrovány. Tato metoda dosahuje výborných výsledků, ale je velmi výpočetně náročná. Optimalizovanou alternativou je Sampling Ant-Aliasing (MSAA). Jedná se o metodu fungující na stejném principu, ale namísto navýšení rozlišení celého renderovaného snímku dochází k výběru oblastí, u kterých je velká pravděpodobnost vzniku aliasingu a super sampling probíhá pouze v těchto oblastech.

Z rodiny IAA uveďme Morphological Anti-Aliasing (MLAA). Tato metoda si dává za cíl minimalizovat aliasing z okrajů a siluet. Algoritmus detekuje podezřelé oblasti podle rozdílu sousedních pixelů a používá rozmazání s okolím. Detekce aliasingu může být i složitější, jako například vyhledávání specifických tvarů.


Vybraný zástupce GAA je Geometric PostProcessing AA (GPAA). Při renderování obrazu dochází k ukládání informací o geometrii scény do separátního bufferu. Podle vzdálenosti sousedních pixelů ve finálním kroku dochází k rozhodnutí, zda je nutné provádět anti-aliasing. Pokud ano, jsou vypočteny hodnoty okolních pixelů a dochází k rozmazání.

figure[H]
		obrazky-figures/ssaa_diff.png
	Rozdíl kvality obrázku po použití SSAA
	fig:aliasing
figure




Voxel voxels
Jak uvádí knihagfx_principles_practice, voxel, neboli volume element, reprezentuje hodnotu na pravidelné mřížce ve 3D prostoru (obrázek fig:3d_grid). Díky tomu, že je prostor rozdělen mřížkou pravidelně, lze voxel definovat pomocí třísložkového vektoru (rovnice eq:voxel_coords). Pro účely vykreslování jsou voxelům přiřazovány další vlastnosti, jako například barva nebo materiál.

equation eq:voxel_coords
	gathered
	pozice_voxel Z_3
	gathered
equation

figure[H]
		obrazky-figures/3d_grid.png
	3D mřížka
	Zdroj: 3d_grid_image
	fig:3d_grid
figure

Voxely jsou často využívány v medicíněmedical_vox, například pro výstupy magnetické resonance (obrázek fig:mri_vox).

figure[H]
		obrazky-figures/voxel_mri.png
	Zobrazení výsledku magnetické resonance pomocí voxelů
	Zdroj:mri
	fig:mri_vox
figure

Dalším častým využitím je modelování terénu; voxely přináší možnost reprezentovat převisy, čímž je terén značně realističtější než při aplikaci často používaných výškových map. Pravděpodobně nejznámější software používající voxely pro terén je Minecraft (obrázek fig:minecraft). Za zmínku stojí také hra Teardown (2020)(https://www.teardowngame.com/), kde je celý herní svět vytvořen pomocí voxelů a umožňuje téměř neomezenou destrukci.

figure[H]
		obrazky-figures/minecraft.jpg
	Minecraft
	Zdroj: https://forums-cdn.spongepowered.org/uploads/default/original/2X/8/83abd20efc6cf5104c2f8c5459808bcd1addef7a.jpg
	fig:minecraft
figure

Vykreslování voxelových modelů
Níže jsou popsány základní metody vykreslování voxelových modelů. Jedná se jen o základní příklady, ve skutečnosti existuje mnohem více metod, než by bylo rozumné zde popisovat.

Rasterizace
Pro vykreslování voxelových scén pomocí rasterizace je nutné ji převést na trojúhelníkovou reprezentaci. Toho se dá dosáhnout několika způsoby.

Instanced rendering je velice primitivní metoda. Pro každý voxel, který je reprezentován přímo svojí pozicí a případně dalšími parametry (barva...), je vykreslena krychle o předem určené délce hran. Před samotným vykreslováním musí docházet k odstranění takových voxelů, které nejsou viditelné. Pokud by byl tento krok vynechán, bylo by vykreslování velice náročné.nousiainen_2019

center
	czechalgorithm[H] alg:instanced_cube
	voxelarray = cullvoxels(allvoxels)

	voxel in voxelarray 

	rendercube(voxel.position)

	

	Instancované vykreslování
	czechalgorithm
center

Marching cubesmarching_cubes je příkladem algoritmu pro extrakci povrchu z voxelových dat. Původně představen pro vizualizaci dat v medicínském odvětví, je současně využíván například pro vizualizaci terénunguyen_2008. Pro každou oblast v mřížce prostoru je zjištěno, který z rohů voxelu se nachází uvnitř či vně tělesa. Na základně toho je vypočten tvar a pozice generovaných trojúhelníků. V některých úpravách algoritmu je možné značně snížit počet vygenerovaných trojúhelníků a snížení redundantnosti dat. Po vygenerování často dochází k minimalizaci počtu trojúhelníku. Následuje zjednodušená verze algoritmu.

center
	czechalgorithm[H] alg:marching_cubes
	voxel in area 

	case = calculatecase(voxel)

	triangles = generatetriangles(voxel.position, case)

	result.add(triangles)

	

	Marching cubes
	czechalgorithm
center

Existují další metody, jako například marching tetrahedra, ale tato práce rasterizačních metod nevyužívá a proto tu nebudou dále zmiňovány.

Ray casting sec:voxel_intersection
Při vykreslování pomocí paprsků lze problém rozdělit na dvě části. První z nich je výpočet průsečíku s voxelem a druhým je využití hierarchické struktury pro minimalizaci počtu navštívených voxelů. Hierarchické struktury jsou v samostatné sekci.

Průsečík paprsku s voxelem lze počítat mnoha způsoby. Primitivní přístup k řešení tohoto problému je počítat průsečík s každou rovinou, která reprezentuje voxel a následně vybrat ten nejbližší (algoritmus alg:ray_box_primitive). Tohle řešení je ale poněkud náročné a využívá podmínky, což může podle článkugpu_branch značně zpomalit výpočet.

center
	czechalgorithm[H] alg:ray_box_primitive
	corner_1 = voxel.position

	corner_2 = voxel.position + voxellength

	coeffs[0] = (corner_1.x - ray.origin.x) / ray.direction.x

	coeffs[1] = (corner_1.y - ray.origin.y) / ray.direction.y

	coeffs[2] = (corner_1.z - ray.origin.z) / ray.direction.z

	coeffs[3] = (corner_2.x - ray.origin.x) / ray.direction.x

	coeffs[4] = (corner_2.y - ray.origin.y) / ray.direction.y

	coeffs[5] = (corner_2.z - ray.origin.z) / ray.direction.z

	hit = false

	distance = 

	coef in coefs 

	coef >= 0 

	hit = true

	hitpoint = ray.origin + ray.direction * coef;

	isinboxbounds(corner_1, hitpoint)

	distance = coef

	
	
	
	Primitivní výpočet průsečíku s voxelem
	czechalgorithm
center

Vhodnější alternativou pro výpočet průsečíku paprsku s voxelem lze najít v publikaciefficient_box_intersect. Tato metoda využívá dlaždic (slabs), kdy je voxel považován za průsečík tří z nich. Na obrázku fig:slabs je vizualizace výpočtu ve 2D - ve 3D je výpočet obdobný. Algoritmus pro 2D je popsán v rovnici eq:slabs.


equation eq:slabs
	gathered
	x_min = p_x + t_xmin d_x

	t_xmin = (x_min - p_x)d_x

	

	y_min = p_y + t_ymin d_y

	t_ymin = (y_min - p_y)d_y

	

	t_xenter = (t_xmin, t_xmax)

	t_xexit = (t_xmin, t_xmax)

	

	t_yenter = (t_ymin, t_ymax)

	t_yexit = (t_ymin, t_ymax)

	

	t_exter = (t_xenter, t_yenter)

	t_exit = (t_xexit, t_yexit)

	gathered
equation

figure[H]
		obrazky-figures/slab_intersect.png
	Průsečík s voxelem metodou dlaždic
	Zdroj:Cunha13
	fig:slabs
figure


Používané formáty sec:format
Pro ukládání voxelových scén existuje poměrně velké množství formátů. Bohužel neexistuje žádný standardizovaný formát, i když nějaké pokusy o to již byly (například VolDat(http://www.volumesoffun.com/voldat-format/)). Následuje popis vybraných formátů.

Vox formát byl vytvořen pro aplikaci MagicaVoxel(http://ephtracy.github.io/), což je modelovací software pro voxelové scény. Jedná se o binární formát, kde jsou barvy zakódovány pomocí palety. Také podporuje různé typy materiálů, ač s malým množstvím parametrů. Jelikož MagicaVoxel nepodporuje větší modely než 256x256x256 voxelů, zpravidla v tomto formátu větší scény nejsou. Specifikace formátu jsou v vox_format.

SVX (Simple Voxels) je archivový formát. Archiv obsahuje soubor manifest.xml, který popisuje velikost mřížky, velikost voxelů, paletu materiálů a další metadata. Samotné voxely jsou popsány pomocí obrázků v jednokanálovém formátu PNG, přičemž každý pixel slouží jako odkaz do palety modelů. Tento formát je používán především pro 3D tisk. Specifikaci formátu najdete nasvx_format_2014.

Existuje spousta dalších formátů, značné množství pro 3D tisk, ale také pro využití v medicíně, jak již bylo zmíněno dříve. Dle mého průzkumu je nejčastějším přístupem při volbě formátu pro vykreslovací engine vytvořit formát vlastní.


Hierarchické struktury
Jak již bylo zmíněno, pro efektivní práci s velkým množstvím voxelů je potřeba využít akceleračních struktur. V této sekci najdete popis některých struktur, které se dají pro voxely použít.

Mřížka
Mřížka, nebo také grid, je poměrně jednoduchá struktura pro dělbu prostoru. Na nejnižší úrovni může mřížka odpovídat té, pomocí které dělí prostor samotné voxely. V takovém případě by však nedošlo k žádnému zrychlení. Pro akceleraci je prostor obsahující voxely rozdělen do několika částí (tzv. chunks). V těchto oblastech jsou voxely sdružovány a při hledání požadované položky můžeme nejdřív vybrat správný chunk a pak teprve vyhledávat v omezené množině voxelů. Samotná struktura má minimální paměťové nároky, ale nepřináší velké zrychlení, alespoň ve srovnání s ostatními metodami. Jednoduchá trojrozměrná mřížka je na obrázku fig:3d_grid.

Hierarchie obalových těles sec:BVH
Obalové těleso (bounding volume) je jednoduchý geometrický objekt, který obaluje jeden či více objektů s větší komplexitouericson_2005. Důležitým faktorem pro vhodnost tělesa k využití v hierarchii obalových těles (bounding volume hierarchies) pro ray tracing je náročnost výpočtu průsečíku s tělesem. Jako příklad můžeme uvést kouli (rovnice eq:sphere_ray_intersection), osově zarovnaný obdelník (axis aligned box) nebo konvexní obálku. 

equation eq:sphere_ray_intersection
	gathered
	    R(t) = o + td  

	    
	    (P + td - C) (P + td - C) = r^2
	    
	gathered
equation

eqexpl[60mm]
 paprsek
 počátek paprsku
 vzdálenost průsečíku
 směr paprsku
 střed koule
 poloměr koule
eqexpl

Samotná hierarchie těchto těles je tvořena jako stromová struktura, kdy každý nelistový uzel obsahuje zpravidla 2 potomky. Obalové těleso reprezentující nelistové uzly je vytvořeno tak, aby ohraničovalo pouze prostor nutný k obsažení jeho potomků.

figure[H]
		images/fig03-bvh.png
	2D hierarchie obalových těles
	Zdroj: https://developer.nvidia.com/blog/thinking-parallel-part-ii-tree-traversal-gpu/
	fig:slabs
figure

Díky snadnosti výpočtu průsečíků a možnosti netestovat průsečíky s nižšími úrovněmi stromu - a tím i komplexními objekty - může dojít k výraznému zrychlení výpočtu průsečíku se scénou. Algoritmus alg:bvh_traverse_naive popisuje jednoduchý průchod binárním stromem za pomocí zásobníku.

center
	czechalgorithm[H] alg:bvh_traverse_naive
	currentnode = root

	stack = empty()

	exit = false

	!exit 

	isInternalNode(currentnode)
	    intersectNode(currentnode)
	        pushStack(stack, currentnode.firstchild)

	        currentnode = currentnode.secondchild

	    
	
	    intersectLeaf(currentnode)

	    (currentnode, exit) = popStack(stack)

	
	

	Průchod BVH stromem pro ray tracingVaidyanathan2019WideBT
	czechalgorithm
center



Octree octree
Octree, poprvé představen v knizerensselaer1980octree, je popsán jako hierarchický N-dimenzionální binární strom, jenž reprezentuje N-dimenzionální objekt. Pro naše účely podstatná pouze jeho 3D varianta. Každý uzel stromu obsahuje 8 potomků na další úrovni. Tyto uzly reprezentují oblast v prostoru. Pokud uzel kompletně popisuje oblast, kterou reprezentuje, jedná se o list nebo koncový uzel, v opačném případě musí obsahovat 8 potomků pro podoblasti. Při hledání objektů v prostoru tedy můžeme procházet pouze velmi omezenými oblastmi a neplýtvat výpočetní výkon.

figure[H]
		obrazky-figures/Octree2.pdf
	Octree
	Zdroj: https://en.wikipedia.org/wiki/Octree
	fig:slabs
figure


Sparse voxel octreesvo_alg
Renderovací metoda využívající ray casting/tracing pro vizualizaci voxelových scén. Důležitou částí generování octree pro tento algoritmus je minimalizace uzlů, které nejsou viditelné, či spojení stejných uzlů do jednoho bloku na vyšší úrovniLaine2011EfficientSV. Výhodou je velmi snadná aplikace level of detail napříč stromem. Podle velikosti pixelu je možné zastavit průchod stromem před dosažením nejnižší úrovně a vypočítat výslednou barvu z uzlu na vyšší úrovni. Algoritmus alg:svo popisuje jednoduchou verzi algoritmu.

center
	czechalgorithm[H] alg:svo
	voxel = tree.getroot()

	not terminated

	(hit, t) = intersectcube(ray, voxel)

	hit

	isvoxelsmall(voxel, pixelsize)  isvoxelleaf(voxel)

	t

	

	stack.push(voxel)

	voxel = selectchild(voxel)

	continue
	 

	voxel = stack.pop()
	

	

	false
	Sparse voxel octree ray casting
	czechalgorithm
center

Vulkan API
Vulkan je API pro 3D grafiku a výpočty pomocí GPUvulkan_web. Cílem Vulkan je poskytnout uživateli možnost vyvíjet vysoce výkonné grafické aplikace. V porovnání s OpenGL či podobnými staršími API přináší výrazně vyšší výkon, ovšem práce s ním je poněkud časově náročnější, jelikož Vulkan pracuje na výrazně nižší úrovni, než jeho předchůdci. Byl také navržen s předpokladem, že bude používán z více vláken. Některé výhody Vulkan oproti předchozím grafickým API:

itemize
	Jednotné API jak pro mobilní zařízení, tak pro PC.
	Dostupnost na velkém množství operačních systému (podobně jako OpenGL).
	Nízký overhead driverů.
	Pro shadery používá binární formát SPIR-V(https://www.khronos.org/opengl/wiki/SPIR-V), díky čemuž můžou vývojáři distribuovat pouze binární formu shaderů.
	Sjednocení grafického (graphics pipeline) a výpočetního (compute shaders) API.
	Ray tracing pomocí rozšíření (tuto funkci podporuje i DirectX12).
itemize

Současnou verzí API je Vulkan 1.2.184vulkanspec.

Návrh řešení
navrh
V této kapitole je popsán návrh aplikace pro realistické zobrazování voxelových scén. Kapitola je rozdělena na část popisu reprezentace voxelových dat a dále jejich vykreslování pomocí sparse voxel octree algoritmu.

Reprezentace voxelových datsec:voxel_representation
Jak bylo popsáno v sekci voxels, voxely jsou reprezentovány svou pozicí a jejich materiální vlastnosti různými parametry. Logickým krokem je rozdělení těchto dvou věcí. V některých strukturách můžeme kódovat implicitně a nemusíme tedy plýtvat paměťovým prostorem.

Pro implicitní zakódování pozice lze využít octree (sekce octree). Nejnižší úroveň stromu reprezentuje samotné voxely a jediným nutným parametrem je počáteční pozice stromu a velikost prostoru, který obaluje. Samotný strom by mohl být vytvořen se statickým rozestupem rodičů a potomků, kde by se výpočet indexu následníka mohl řídit rovnicí:

equation eq:simple_octree_index
	gathered
	I_child_j = (i * 8) + j
	gathered
equation

kde  je index -tého potomka,  je index současného uzlu. Při použití tohoto rozložení by ovšem musela být celá oblast uvnitř octree rozdělena na nejmenší bloky a docházelo by k obrovskému plýtvání paměti.

Úsporný způsob pro reprezentaci octree byl představen v Laine2011EfficientSV. Metoda kóduje informace o uzlu bitově na data o velikosti 4 bytů. Vizualizace je na obrázku fig:octree_child. Každý nelistový uzel je reprezentován svými daty, listové uzly jsou implicitně kódovány pomocí masek. Child pointer určuje pozici potomků uzlu pro daný uzel. Je uložen jako rozdíl od pozice současného uzlu, čímž si jej můžeme dovolit reprezentovat menším rozsahem. Přepínač far určuje, zda child pointer odkazuje na pozice potomků, či na 32 bitový ukazatel na ně - při velkých stromech nemusí být 15 bitů dostačující. Tento pointer je uložen v oddělené části bufferu. Valid mask je bitová maska o velikosti 8 bitů, pokud je hodnota nastavena na 1, pak je ve stromu potomek na tomto indexu reprezentován. Leaf mask odpovídá funkci valid mask, dává nám ovšem vědět, jestli je potomek na indexu terminálním uzlem. Pokud je tedy nastavena na 1, tak je vyhledávání ve stromu na této úrovni ukončeno.

figure[H]
		obrazky-figures/octree_child_data.png
	Položka reprezentující uzel octree
	Zdroj:Laine2011EfficientSV
	fig:octree_child
figure

Samozřejmě krom informací o obsazenosti prostoru je nutné ukládat i informace o materiálu. První možností by bylo rozšířit záznamy ve stromu o tato data, ale s velkým množstvím parametrů by velikost stromu rapidně narostla. Proto by bylo vhodnější tato data ukládat separátně. Tyto informace také nejsou relevantní při procházení stromu a pokud by byla uložena ve struktuře, byla by zhoršena lokalita paměti. Vhodným řešením je za oblastí stromu vytvořit oblast s ekvivalentní strukturou, kde jsou uloženy odkazy na materiálová data. Výpočet offsetu do struktury je triviální, jelikož je pozice dat na stejném indexu jako je index uzlu. Nalezené položky slouží k vyhledávání specifického záznamu v separátním bufferu. Výhodou tohoto přístupu je možnost snadno ukládat samostatné materiály pro vyšší úrovně stromu, což může být použito pro aplikaci level of detail.

Vykreslovánísec:rendering
Pro rendering voxelové scény existuje několik možností, vhodným kandidátem je přístup sparse voxel octree (sekce svo_alg). Při vržení paprsku dochází k procházení stromu a vcházení pouze do podoblastí, které mohou obsahovat vyhledávaný voxel. Algoritmus je velice úsporný oproti primitivním metodám.

figure[H]
		obrazky-figures/color_iter_svo.png
	Render voxelizované "Utah teapot", vlevo barevný výstup, vpravo počet iterací 
	fig:octree_child
figure

Vzhledem ke způsobu uložení dat, který byl představen v minulé sekci, je v rámci algoritmu nutné dopočítávat množství indexů uzlů na základě masek (valid mask a leaf mask). Jedná se ale zpravidla pouze o operace sčítání či odčítání a nejsou tedy příliš výpočetně náročné.

Pro výpočet průsečíku s voxelem je vhodné využít optimálnější metody popsané v sekci sec:voxel_intersection. Pro tuto metodu existuje množství optimalizací, které budou posléze v projektu využity. Například optimalizace uvedena v publikaciMajercik2018Voxel. Důležitou součástí pro stínování je také získání normály povrchu. Vzhledem k tomu, že mám v úmyslu zachovat "krychlovitý" tvar voxelů, je nalezení normály při využití slab metody pro nalezení průsečíku poměrně triviální.

figure[H]
		obrazky-figures/normals_teapot.png
	Render voxelizované "Utah teapot", vizualizace normál 
	fig:octree_child
figure


Pro usnadnění práce s modely a úsporu výpočetního výkonu při jejich transformaci má každý model svoji vlastní octree strukturu. Nutnost otestovat průsečíky se všemi těmito modely by byla velice náročná a proto je vhodné použít další akcelerační strukturu k urychlení nalezení průsečíku. Zvolil jsem hierarchii obalových těles (sekce sec:BVH) s využitím osově zárovnaných obdelníku. Každý listový uzel této hierarchie tedy obsahuje jeden octree, který definuje voxely modelu. 

figure[H]
		images/bvh_octree.png
	Reprezentace scény - levá část reprezentuje hierarchii obalových těles, obsahující v listech octree (vpravo)
	fig:scene_bvh_repr
figure

Tuto metodu jsem se rozhodl použít pro výpočet primárních paprsků kvůli vysoké přesnosti a poměrně nízké výpočetní náročnosti tohoto algoritmu. Metoda pro výpočet sekundárních paprsků je popsána v následující sekci.

Light field probes
Light field probes byly již krátce představeny v sekci sec:ray_tracing. Každá sonda je reprezentována svou pozicí a texturou, která obsahuje následující informace:
itemize
 Radiální vzdálenost ke geometrii.
 Normálu.
 Informace o materiálu, barvě či jiná data využitá v další práci se sondami.
itemize

Tato textura má velikost 1024x1024 a každý texel reprezentuje dvě float hodnoty (rg32f). Vzhledem k tomu, že paměťová náročnost je poměrně vysoká, je nutné ukládaná data nějakým způsobem komprimovat. Radiální vzdálenost ke geometrii je možné logaritmizovat pro zachování vyšší přesnosti pro bližší objekty a také kvantizovat na snížení paměťové náročnosti. Logaritmizace a linearizace hloubky je v rovnici eq:depth_econde_decode.

equation eq:depth_econde_decode
	gathered
	encodeddepth = log(C depth + 1)log(C Far)

	decodeddepth = (C Far + 1)^encodeddepth - 1C
	gathered
equation

Kde  je konstanta modifikující rozložení přesnosti, často nastavena na 1,  je hloubka a  je maximální vzdálenost. Po logaritmizaci je hodnota transformována na 16 bitů a uložena do textury sondy.

Dalším parametrem jsou normály. Ty lze zakódovat na 2 float hodnoty mnoha metodami, jak je uvedeno vCigolle2014ASO. Zvolil jsem metodu projekce na osmistěn. Po projekci jsou složky výsledného vektoru kvantizovány na 8 bitů, čímž je celková potřebná paměť pro uložení těchto hodnot snížena na 16 bitů. Rovnice eq:normal_encode popisuje zakódování normály a eq:normal_decode její dekódování.

equation eq:normal_encode
	gathered
	p = normal.xy 1.0normal.x + normal.y + normal.z 

	encodednormal = cases
            (1.0 - p.yx) * sign(p),& pokud  normal.z 0.0

            p,              & jinak
        cases

	gathered
equation

Kde  je normála,  je pomocný vektor k projekci a  je zakódovaná normála.

equation eq:normal_decode
	gathered
	    z = 1.0 - encodednormal.x - encodednormal.y

	    v = encodednormal.xy, z 

	decodednormal = cases
            (1.0 - v.yx) * sign(v.xy), v.z ,& pokud  v.z < 0.0

            normalize(v),              & jinak
        cases

	gathered
equation

Kde  je zakódovaná normála,  je vypočtená třetí složka výsledné normály,  je pomocný vektor a  je dekódovaná normála.

Poslední položkou uloženou v textuře sondy je radiance. Pro případné další rozšíření je uložena ve formátu R11G11B10 pro podporu HDR.

Jelikož sonda reprezentuje světelné pole ve svém okolí jakožto kouli, je nutné data nějakým způsobem transformovat na texturu, tedy rovinu. Toho lze dosáhnout mapováním koule na osmistěn a následné projekce na rovinu, jak je znázorněno na obrázku fig:octahedral_wrap. Pro tuto projekci a její inverzní operaci je možné využít rovnic eq:normal_encode a eq:normal_decode.

figure[H]
		images/octahedral_wrap.png
	Vizualizace projekce na osmistěn a následně na rovinu
	fig:octahedral_wrap
figure

Výpočet informací o geometrii je prováděn pomocí ray tracingu představeném v sekci sec:rendering. Na obrázku fig:probe_in_scene je ukázka dat jedné ze sond.


figure[H]
		images/probe_with_scene.png
	Vizualizace dat uložených pro sondu (horní část v pořadí radiance, normály, hloubka) a její pozice ve scéně (dolní část, červená koule je zobrazovaná sonda)
	fig:probe_in_scene
figure

Renderování scény pomocí této metody
Pomocí atlasu textur, který byl vytvořen pro všechny sondy pokrývající scénu, je možné provádět trasování paprsku. Tato metoda byla popsána v publikacilight_field_probes. Díky radiální vzdálenosti a normálám zakódovaných v sondách můžeme vypočítat průsečíky nesouvislých paprsků. 

V prvé řadě je nutné pro paprsek vybrat vhodnou sondu, ve které zahájíme jeho sledování. Pokud tato sonda není schopná poskytnout nám jistý miss (minutí scény) nebo hit (protnutí scény) je nutné vybrat alternativní sondu, která má nějakou šanci paprsek sledovat. Sledování paprsku v rámci jedné sondy tedy vrací tři stavy:
itemize
    miss - minutí scény
    hit - průsečík se scénou
    unknown - neznámý výsledek
itemize

Stav unknown nastane pouze v případě, kdy paprsek prochází ve větší vzdálenosti, než jaká je v daná pozici radiální hloubka. Jinými slovy, pokud sonda "ví", že nemá dostatečné informace o scéně v dané pozici, nemůže být paprsek spolehlivě vyhodnocen pouze pomocí informací z této sondy. 

Sledování paprsku začíná jeho převedením jeho počátku do prostoru sondy, následně je paprsek transformován pomocí projekce na osmistěn do souřadnic textury. Dochází tedy k transformaci přímky z  do křivky v . Tato křivka má až čtyři segmenty, kde každý segment leží v jiné stěně osmistěnu. Následně algoritmus postupuje po jednotlivých texelech nacházejících se na této křivce a vyhodnocuje, jestli dochází k průsečíku pomocí porovnávání uložené hloubkové mapy se vzdáleností paprsku k sondě. Pokud je paprsek ve stejné vzdálenosti, nebo je dále, dochází k průsečíku nebo paprsek prochází za geometrií. Algoritmus pro výpočet průsečíku je v algoritmu alg:single_probe_trace. 

center
	czechalgorithm[H] alg:single_probe_trace
	    segments = computesegments(ray, probe)

	    segment in segments
	        coordsonsegment = createcoords(segment)

	        coord in coordsonsegment
	            state = compareraydistancetoradial(ray, coord, probe)

	            state == HIT
	                (HIT, coord)
	            
	            state == HIDDENBEHINDSURFACE
	                (UNKNOWN, coord) 
	            
	        
	    
	    (MISS, lastpointonsegments)
	Sledování paprsku v rámci jedné sondy
	czechalgorithm
center

Pro urychlení tohoto algoritmu je pro každou sondu vytvořena další textura, která má 16-krát menší velikost - tedy 64x64 - ve které jsou uloženy v každém texelu nejbližší radiální vzdálenosti. Jedná se prakticky o mipmapu. Při procházení pixelů segmentů tedy není nutné provádět algoritmus na maximálním rozlišení, čímž dochází k výraznému zrychlení. Pouze při nalezení potenciálního průsečíku je trasování prováděno na vysokém rozlišení. Na obrázku fig:lfp_trace je vizualizace průchodu paprsku jednou sondou.

figure[H]
		images/lfp_trace.png
	Vizualizace sledování paprsku v textuře sondy. Oranžová část je prováděna pouze na textuře s nižším rozlišením, zelená při nalezení potenciálního průsečíku
	fig:lfp_trace
figure

Výběr sondy. Samozřejmě nejdůležitějším krokem je výběr vhodné sondy pro zahájení algoritmu. Jedním možným řešením je výběr sondy čistě podle vzdálenosti k počátku paprsku, což doporučuje taktéž článeklight_field_probes, s tím, že výběr dalších sond se řídí pořadím uvedeným v obrázku fig:lfp_cube. Pokud se paprsek nenachází v jiné skupině sond po dokončení průchodu této skupiny je hledání ukončeno jako neúspěšné, jinak je prováděno v nové skupině. V mém případě docházelo k velkému množství unknown výsledků a proto jsem se rozhodl implementovat jiné řešení. 

figure[H]
		images/probe_cube.png
	Pořadí výběru sondy pro lokální skupinu
	fig:lfp_cube
figure

Namísto výběru sondy tak, jak je popsáno v předchozím odstavci, je možné rozdělit prostor, který je sondami sledován, na voxelové pole (mřížku). Toto pole obsahuje pro každý voxel až čtyři sondy, pro které se daný voxel vyskytuje blíže, než je jejich radiální vzdálenost ke scéně. Namísto výběru nejbližší sondy tedy vybereme sondu podle toho, ve kterém voxelu se paprsek současně nachází. Sledování ukončíme pouze tehdy, pokud žádná ze sond uložená v tomto poli nenalezla řešení a sledovaný bod paprsku se neposunul do jiného voxelu. 

center
	czechalgorithm[H] alg:light_field_trace
	    result = UNKNOWN

	    result == UNKNOWN
	        probe = selectprobefromvoxelfield(ray)

	        isvalidprobe(probe)
	            break
	        
	        (result, endpoint) = tracesingleprobe(ray, probe)

	        ray.origin = endpoint
	    
	    result
	Sledování paprsku skrze light field
	czechalgorithm
center

Na obrázku fig:lfp_scene_render je zobrazena scéna vykreslená čistě pomocí výše popsané metody. Zelené oblasti značí miss, červené unknown. Je vidět, že dochází k mnoha nepřesnostem a ve scéně, kde je spousta objektů dochází ke vzniku míst, kde sondy nenaleznou řešení.

figure[H]
		images/probe_scene_render.png
	Scéna vykreslena pomocí sledování paprsku skrze light field
	fig:lfp_scene_render
figure

Nepřímé osvětlení
Mým původním záměrem bylo využít výše popsané sondy k výpočtu sekundárních paprsků ve scéně online, ale ukázalo se, že pro takový přístup je tato metoda příliš pomalá. Bylo tedy nutné vymyslet alternativní řešení. 



Implementace
implementace

Tato kapitola obsahuje seznam použitých nástrojů a knihoven. Popisuje implementaci knihoven vytvořených při práci na praktické části tohoto projektu, také algoritmy použité ke tvorbě octree a uživatelské rozhraní demonstrační aplikace.

Použité knihovny a nástroje
Pro implementaci jsem zvolil jazyk c++, standard 20(https://en.cppreference.com/w/cpp/20), kvůli mé pokročilé znalosti jazyka a také jako možnost procvičit si nově přidané funkce v poslední revizi. Pro překlad projektu jsem použil CMake(https://cmake.org/) v kombinaci s Ninja(https://ninja-build.org/) a package management nástroji CPM.cmake(https://github.com/TheLartians/CPM.cmake) a Hunter(https://hunter.readthedocs.io/en/latest/). Jako vývojové prostředí jsem využil CLion(https://www.jetbrains.com/clion/). Kód shaderů je vytvořen v GLSL(https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)). Při práci na projektu jsem také využil tyto knihovny třetích stran:

itemize
	AutoMultiColItemize
	spdlog(https://github.com/gabime/spdlog)
	range-v3(https://github.com/ericniebler/range-v3)
	magicenum(https://github.com/Neargye/magic_enum)
	argparse(https://github.com/p-ranav/argparse)
	toml++(https://marzer.github.io/tomlplusplus/)
	backward-cpp(https://github.com/bombela/backward-cpp)
	cppcoro(https://github.com/lewissbaker/cppcoro)
	fmt(https://github.com/fmtlib/fmt)
	stb(https://github.com/nothings/stb)
	glm(https://github.com/g-truc/glm)
	Dear ImGui(https://github.com/ocornut/imgui)
	AutoMultiColItemize
itemize

Dále jsem použil následující nástroje pro statickou analýzu kódu, formátování atp.:
itemize
	AutoMultiColItemize
	cppcheck(http://cppcheck.sourceforge.net/)
	cpplint(https://github.com/cpplint/cpplint)
	sanitisers(https://github.com/google/sanitizers)
	valgrind(https://valgrind.org/)
	Ccache(https://ccache.dev/)
	clang-format(https://clang.llvm.org/docs/ClangFormat.html)
	AutoMultiColItemize
itemize

Knihovna pfcommon
Knihovna poskytující často používané funkce:
itemize
	Concepty pro template meta programování a statický polymorfimus.
	Jednoduché coroutines (iota, range...)
	Implementace výjimek se stack trace reporting.
	Některé idiomy c++ - RAII, Visitor...
	Funkce pro binární serializaci dat a práci s binárními daty.
	Obecné geometrické funkce, které nejsou poskytnuty v glm.
	Funkce pro rozšíření možnosti využití enum.
	Mnoho dalších...
itemize

Je implementována jako header-only knihovna(https://en.wikipedia.org/wiki/Header-only).

Knihovna pfglfwvulkan
Tato knihovna poskytuje dvě základní funkce:
itemize
	vytvoření a správa okna pomocí GLFW(https://www.glfw.org/)
	komunikace s GPU za pomocí Vulkan API(https://www.khronos.org/vulkan/)
itemize

Třída GlfwWindow umožňuje instanciaci GLFW knihovny a také komunikaci za pomocí událostí, které knihovna programu předává. Tato třída splňuje concept(https://en.cppreference.com/w/cpp/language/constraints) Window, který je také obsažen v knihovně. Za pomocí Window je implementována komunikace mezi Vulkan a okenním systémem - díky tomuto rozdělení si může uživatel vytvořit komunikační vrstvu mezi knihovnou a jiným okenním systémem, jako například SDL(https://www.libsdl.org/). Pro tento účel implementuje knihovna vlastní notifikační systém událostí ve třídě EventDispatchImpl, který výrazně usnadňuje případnou implementaci s jiným okenním backendem.

Část knihovny pro interakci s Vulkan je o poznání rozsáhlejší. Při návrhu knihovny byl kladen zřetel především na její jednoduchost a zároveň bezpečnost jejího užívání. Z tohoto důvodu je uvnitř hojně využito std::sharedptr. Vzhledem k tomu, že ve Vulkan často musíme vytvářet objekty v závislosti na některém z dříve vytvořených (například vk::Instance  vk::PhysicalDevice  vk::Device) si v sobě každý nově vytvořený potomek ukládá ukazatel na svého "rodiče". To zaručuje, že nemůže dojít k uvolnění objektů omylem, v případě, že budeme používat některého z jeho potomků.

Knihovna obsahuje vlastní verzi velkého množství Vulkan objektů a zároveň je plně typově bezpečná. Příkladem může být přístup do vk::Buffer, kdy k datům přistupujeme pomocí mapovacího objektu, který hojně využívá template funkcí pro kontrolu offsetu a správné práce s pamětí.

Všechny objekty jsou potomkem VulkanObject, což je rozhraní, které poskytuje základní debug informace o objektu. Vytváření objektů je vždy prováděno pomocí struct konfiguračních dat. Předpokládá se užití designated initialisers(https://en.cppreference.com/w/cpp/language/aggregate_initialization#Designated_initializers). Ukázka vytvoření logického zařízení:

lstlisting[language=C++, caption=Tvorba logického zařízení]
// tvorba instance vynechana kvuli velkemu mnozstvi argumentu
device = instance->selectDevice(DefaultDeviceSuitabilityScorer());
surface = instance->createSurface(window);
logicalDevice = device->createLogicalDevice(
    .id = "dev1",
    .deviceFeatures = vk::PhysicalDeviceFeatures,
    .queueTypes = vk::QueueFlagBits::eCompute,
    .presentQueueEnabled = true,
    .requiredDeviceExtensions = VK_KHR_SWAPCHAIN_EXTENSION_NAME,
    .validationLayers = getValidationLayers(),
    .surface = *surface);
lstlisting

Pro objekty, u nichž by konfigurační struktura vyžadovala nadměrně velké množství argumentů, jsou v knihovně dostupné builder třídy, například GraphicsPipelineBuilder nebo RenderPassBuilder.



Knihovna pfimguisec:pf_imgui
pfimgui je event-driven UI knihovna postavena na Dear Imgui. Cílem je zjednodušení práce při vytváření uživatelského rozhraní a také přidání některých funkcí. Funkce, které jsou oproti Dear Imgui přidané jsou:

itemize
	Pozorování změn hodnot pomocí callback funkcí (observer pattern).
	Ukládání hodnot do konfiguračního souboru. Tyto změny jsou načteny vždy při zapnutí programu.
	Některé elementy navíc, například Memo.
itemize

Knihovna je postavena nezávisle na renderovacím backendu, v repository je poskytnut backend pro Vulkan a GLFW. Pro vlastní použití je nutné rozšířit hlavní objekt ImGuiInterface a přidat volání do backendu své volby. Například pro Vulkan by se mohlo jednat o jednoduchou funkci přidání draw command do vk::CommandBuffer. V knihovně je obsaženo podstatné množství elementů, přičemž jsou implementovány wrappery pro všechny elementy dostupné v Dear Imgui. Také jsou přidány grafy z knihoven ImGuiFlameGraph(https://github.com/bwrsandman/imgui-flame-graph), implot(https://github.com/epezent/implot) a možnost interagovat se soubory na disku pomocí ImGuiFileDialog(https://github.com/aiekick/ImGuiFileDialog).

V knihovně je také implementováno podstatné množství layoutů - grid layout, anchor layout...

Přidání vlastních elementů do knihovny je velice primitivní. Připravená rozhraní pokrývají spoustu potenciální funkčnosti včetně například drag and drop a rozhraní pro nastavení stylu/ barvy elementu. 

Implementace CheckBox vyžaduje jen 10 řádků kódu - nepočítaje deklarace funkcí a tělo konstruktoru - s tím, že dědí z ItemElement, Labellable, Savable, ValueObservable<bool>, ColorCustomizable<...> a StyleCustomizable<...>.

Ukázka vytvoření tlačítka, které reaguje na kliknutí otevřením dialogu pro výběr txt souboru:

lstlisting[language=C++, caption=Vytvoření tlačítka pro výběr souboru]
imgui.createChild<Button>("btn_id", "Open file")
    .addClickListener([&imgui] 
        imgui.openFileDialog("Select file", 
            .ext = "txt", .description = "txt  files", 
            [] (const auto &files) 
                for (const auto &file : files)  print(file); 
            , []  print("No file selected"); );
    
lstlisting


Načítání modelů a jejich transformace sec:voxel_conversion
Pro vykreslování modelů je nutné je transformovat do octree. Jelikož neexistuje žádný standardní formát pro voxely, je potřeba implementovat import pro různé formáty. Aplikace je prozatím schopna importovat formát vox (sekce sec:format)).

Načítání dat je rozděleno na dvě části. V první části jsou ze vstupního souboru načteny využité materiály a je vytvořen seznam voxelů. Tohle je jediná část, kterou je nutné implementovat speciálně pro nové formáty. Zbytek převodu je popsán v algoritmu alg:vox_to_svo.


center
	czechalgorithm[H] alg:vox_to_svo
	voxels.sort() 

	treedepth = calculatetreedepth(voxels)

	root = tree.initroot()

	voxel in voxels
	node = root

	level = 0; level < treedepth; level++ 
	indexforlevel = getIndexForLevel(voxel.position, level, treedepth)

	childnode = node.getorcreatenode(indexforlevel)

	// nastaveni hodnot voxelu (material...)

	node = childnode

	
	node.isterminal = true

	
	Převod voxelů do octree
	czechalgorithm
center

Po vytvoření stromové reprezentace je dalším krokem minimalizace stromu. Pokud jsou některé oblasti zaplněné, můžeme snížit jeho složitost - označíme uzel na vyšší úrovni jako terminální a jeho potomky odstraníme.

center
	czechalgorithm[H] alg:minimize_svo
	FMinTreeMinimizeTree
	FIsFilledIsNodeFilled
	FnFunction:

	
	.childcount == 8  allof(.children, IsFilled)

	

	
	IsNodeFilled()
	node.children.clear()

	node.isterminal = true

	
	
	child in .children
	MinimizeTree(child)

	
	
	
	Minimalizace octree
	czechalgorithm
center

figure[H]
		obrazky-figures/levels_render.png
	Vizualizace voxelů podle jejich hloubky ve stromu, vlevo render, vpravo barevně odlišené úrovně
	fig:imgui_classes
figure



Finálním krokem je transformace vytvořeného stromu do jeho binární reprezentace popsané v sekci sec:voxel_representation.


Výpočet průsečíku se scénou sec:bvh_traversal_impl
Generování paprsků bla bla, BVH:

Algoritmus alg:traverse_bvh_impl popisuje průchod BVH stromem za využití zásobníku. Důležitou součástí tohoto algoritmu je řazení potomků uzlu podle jejich vzdálenosti od počátku paprsku. Díky tomu jsou uzly stromu procházeny v pořadí od nejbližšího, můžeme tedy od určité chvíle naprosto ignorovat modely, jejichž obalové těleso (AABB) se nachází dále než prozatím nejbližší průsečík scény. Je zde také menší pravděpodobnost, že bude docházet k větvení kvůli pořadí průchodu.

center
	czechalgorithm[H] alg:traverse_bvh_impl
	    Oror
        Andand
        Notnot
	FTraverseBVHTraverseBVH
	FIntersectNodeIntersectNode
	FnFunction:

	
	    bestmodelintersectiondistance = INFINITY

	    intersectiona = IntersectNode(root)

	    stack = EmptyStack()

	    intersectiona.hit
	       intersectiona.isleaf intersectiona.hit
	            intersectiona = IntersectNode(intersectiona.node.leftchild)

	            intersectionb = IntersectNode(intersectiona.node.rightchild)

	            intersectiona.distance < instersectionb.distance
	                swap(intersectiona, intersectionb)
	            
	            intersectionb.hit intersectionb.distance < bestmodelintersectiondistance
	                stack.Push(intersectionb)
	            
	            intersectiona.hit stack.Empty()
	                intersectiona = stack.Pop()
	            
	        
	
	    
    	intersectiona.isleaf
    	    intersectiona.distance < bestmodelintersectiondistance
    	        modelintersection = TraceModel(intersectiona.modelid

    	        modelintersection.hit modelintersection.distance < bestmodelintersectiondistance
    	            bestmodelintersectiondistance = modelintersection.distance 
    	        
    	    
    	
    	stack.Empty()
    	    intersectiona.hit = false
    	 
    	    intersectiona = stack.Pop()
    	
	
	Průchod paprsku hierarchií obalových těles
	czechalgorithm
center





Demonstrační aplikace
Demonstrační aplikace slouží k vizualizaci výsledků a práci s modely/scénami. Aplikace může pracovat ve dvou režimech:
itemize
    Editační režim - v tomto režimu je scéna vykreslována pouze pomocí sparse voxel octree ray marchingu a slouží primárně k vytvoření scény a jejímu uložení na disk. Také je lze možné sledovat stav sond.
    Renderovací režim - slouží k načítání scén vytvořených v předchozím režimu a demonstraci výsledného algoritmu.
itemize

Uživatelské rozhraní je implementováno pomocí knihovny pfimgui představené v sekci sec:pf_imgui. Většina prvků uživatelského rozhraní obsahuje tooltipy pro snadné zjištění funkce jednotlivých komponent. Bližší popis se nachází na přiloženém paměťovém médiu, základní přehled zde ale bude uveden.

UI aplikace je rozděleno do následujících částí:

itemize
	Info - zobrazení statistik vykreslování (počet snímků za sekundu, flame graph), informace o kameře a její parametry, a také informace o právě vykreslované scéně.
	Render settings - výběr typu zobrazení (stínování, normály, počet iterací, hloubka v stromě...), ovládání světla.
	Debug - memo pro výstup logů, připravený Chaiscript pro přidávání složitějších funkcí.
	Debug images - okno pro zobrazení textury reprezentující počet iterací při průchodu octree.
	Shader controls - ovládání parametrů pro shadery.
	Probe grid controls - ovládání mřížky sond.
	Models - ovládání modelů zobrazených ve scéně.
	Probes info - vizualizace atlasu sond a renderování scény pomocí něj.
itemize

figure[h]
		justification=centering
	subfigure[t].49
		images/dp_ui_models.png
	Okno pro přidávání a manipulaci s modely
	fig:model_ui
	subfigure
	subfigure[t].49
		images/dp_ui_probes.png
	Okno pro zobrazení atlasu textur sond
	fig:probe_ui
	subfigure
	subfigure[t]1
	        	images/dp_ui_info.png
        	Informační okno
        	fig:info_ui
	subfigure

	Ukázka oken demonstrační aplikace
	fig:UI
figure


Vyhodnocení
testovani
V této kapitole je krátký popis dosažených výsledků týkající se doby převodu vstupních dat a také analýza využití paměti na grafické kartě.

Převod vstupních dat na octree
Převod vstupních dat na octree byl popsán v sekci sec:voxel_conversion. Převod je prozatím prováděn sekvenčně na jednom vlákně, ale v budoucí verzi jej plánuji předělat tak, aby využíval více vláken procesoru. Na obrázku fig:time_convert je graf závislosti času převodu na počtu vstupních voxelů. Graf fig:time_convert_mini zobrazuje stejné měření s aktivovanou minimalizací. Měření byla prováděna s nejvyšší úrovní optimalizací kompilace. Pro měření bylo použito CPU Ryzen 3600 a probíhalo na jednom vláknu za využití knihovny nanobench(https://github.com/martinus/nanobench). Model, který byl v testech použit byly plné koule o různých poloměrech.


figure[H]
	subfigure.5
	tikzpicture[scale=0.7, transform shape]
	axis[
	xlabel=velikost scény [voxely],
	y unit = s,
	ylabel=doba zpracování,
	grid=both
	]
	table [x=size, y=time, mark=none, color=red]data/time_convert.txt;
	axis
	tikzpicture
	Bez minimalizace
	fig:time_convert
	subfigure
	subfigure.5
	tikzpicture[scale=0.7, transform shape]
	axis[
	xlabel=velikost scény [voxely],
	y unit = s,
	ylabel=doba zpracování,
	grid=both
	]
	table [x=size, y=time, mark=none, color=red]data/time_convert_mini.txt;
	axis
	tikzpicture
	S minimalizací
	fig:time_convert_mini
	subfigure
	Čas tvorby octree
figure

I když to není z grafu moc znatelné, transformace s minimalizací je o pár procent rychlejší, jelikož není nutné vytvářet tak velký finální strom. Pokud by vstupní data byla pro minimalizaci nepříznivá, byla by tato metoda pomalejší.

Vzhledem k rychlostem zpracování je jasné, že algoritmy nejsou příliš dobře optimalizované a mám v úmyslu je v budoucnu zrychlit.

Paměťová náročnost
Každý uzel octree zabírá v prvé řadě 4 bajty (15 bitů child pointer + 1 bit far + 8 bitů valid mask + 8bitů leaf mask). Dále pro dohledání materiálů a ostatních parametrů další 4 bajty (24 bitů value pointer + 8 bitů mask). Tyto dva záznamy nejsou vytvářeny pro listové uzly. Pokud budeme předpokládat strom, který má prostor obsazený přesně z 50  a je obsazen pouze každý druhý voxel, s hloubkou stromu 6 - tedy 37448 voxelů - celková obsazená paměť zmíněnými záznamy bude 18724 bajtů. Při popsaném rozložení voxelů se samozřejmě jedná o nejhorší možný případ.

table[H]
		tabularrr
		1chloubka stromu & 1cobsazená paměť [B] 
 	1                                    & 4                                           
 	2                                    & 36                                          
 	3                                    & 292                                         
 	4                                    & 2340                                        
 	5                                    & 18724                                       
 	6                                    & 149796                                      
 	tabular
	Využití paměti podle hloubky stromu při maximální nepříznivosti podmínek
table

Tímto jsou pokryta základní data popisující strom a vyhledávací strukturu do parametrů. Další paměť je využita far pointery. V pesimistickém případě je může potřebovat 5  uzlů, ovšem jsou potřeba až pro hloubku stromu vyšší než 7, kvůli množství potomků v úrovni.

Poslední data vyžadující velké množství paměti jsou samotné parametry voxelů. Samozřejmě záleží na využitých parametrech, pro phongovo stínování je dostačující barva, tedy 4 bajty (RGBA formát, kde je každý kanál reprezentován 8 bity). Samozřejmě se data dají zakódovat efektivněji.

Celková paměťová náročnost pro octree se zmíněnými parametry je tedy:

table[H]
		tabularrr
		1chloubka stromu & 1cvyužití paměti [B] 
 	1                                    & 20                                          
 	2                                    & 164                                         
 	3                                    & 1316                                        
 	4                                    & 10532                                       
 	5                                    & 84260                                       
 	6                                    & 674084                                      
 	tabular
table

Ve všech případech se jedná o nejhorší možný případ. Realisticky použitelné modely mají paměťovou náročnost výrazně nižší a také u nich dochází k minimalizaci stromu (která v uvažovaném nejhorším případě není možná).


Závěr
zaver
Cílem semestrální části diplomové práce bylo nastudovat techniky fotorealistického zobrazování voxelových modelů a nástrojů, pomocí nichž toho lze dosáhnout a také vytvořit kostru aplikace. Demonstrační aplikace je schopna načítat a transformovat modely a také zobrazovat voxelové scény.

V teoretické části dokumentu byl popsán princip realistického zobrazování a některé metody pro dosažení realistického výsledku. Byl popsán například algoritmus ray tracing s některými jeho obměnami. Sekce také představila základy práce s materiály a metody pro odstranění aliasingu. Další sekce vysvětlila princip voxelizace prostoru a představila některá jeho využití. Také zde byly popsány metody pro vykreslení voxelů a základní hierarchické struktury, pomocí nichž lze zmíněné vykreslování akcelerovat.

Kapitola návrhu řešení popsala způsob efektivní reprezentace voxelových dat a vysvětlila její výhody. V této kapitole je taky popsán návrh vykreslování voxelových scén.

Implementační část obsahovala výčet použitých nástrojů a knihoven. Ve zkratce také předvedla knihovny, které byly v rámci tvorby projektu vytvořeny. Tyto knihovny jsou na projektu plně nezávislé a lze je použít pro libovolnou další tvorbu. V kapitole byl také popsán algoritmus pro vytvoření octree z voxelových dat a jeho minimalizace. V poslední sekci bylo krátce popsáno uživatelské rozhraní demonstrační aplikace.

Poslední kapitola, vyhodnocení, se zabývala časovou náročností tvorby a minimalizace octree a paměťové náročnosti této struktury. Algoritmus tvorby octree má velké rezervy a mám v úmyslu ho do budoucna optimalizovat. Paměťová náročnost octree struktury je ale poměrně nízká, z ohledem na to, kolik dat v ní reprezentujeme. V sekci byly uvedeny hodnoty nejhoršího případu.

Cíl další práce je jasný: implementovat alternativní způsob vykreslování (light field probes sec:light_field_probes) a umožnit vykreslování výrazně větších scén. Také optimalizovat načítání scén pro použití v reálném čase a navrhnout způsob reprezentace velkých scén a jejich dynamické načítání z disku.



